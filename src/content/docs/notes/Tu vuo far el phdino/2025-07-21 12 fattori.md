---
title: 2025-07-21 12 fattori
editUrl: false
---

# La Novitade

## Meta

* OpenCitations, Massari, A., & Peroni, S. (2025). OpenCitations Meta Database Dump (9.0.0) \[Data set]. Zenodo. [https://doi.org/10.5281/zenodo.15855112](https://doi.org/10.5281/zenodo.15855112)
* OpenCitations (2025). OpenCitations Meta Provenance Database. figshare. Dataset. [https://doi.org/10.6084/m9.figshare.29543783.v1](https://doi.org/10.6084/m9.figshare.29543783.v1)
* Script per ottenere un subset di qualunque quadstore dando in input la classe da cui partire, il numero di entità da cercare, l'endpoint su cui cercare. A partire da queste entità partono query ricorsive finché ci sono oggetti e i risultati vengono slavati in nquads e, facoltativamente, compressi

## HERITRACE

* Ho creato due script.
  * Il primo crea un pacchetto per fare user testing, sia per gli end user che per i tecnici ,in locale con tutti i file necessari
    * e contiene anche uno script che permette di caricare tre immagini su Docker Hub: una per heritrace, una per il dataset dei dati e l'altro per il dataset di provenance
  * Il secondo script permette di creare dei pacchetti che utilizzano le immagini su Docker Hub per fornire all'utente finale il numero minimo di file possibili su cui lavorare.
* Note
  * L'unica differenza tra il pacchetto per l'utente finale e il pacchetto per il tecnico è il tecnico ha come volume il file shacl e il file display rules che andrà a modificare.
  * L'unica porta esposta all'utente è la porta dell'applicazione principale. Tutte le altre porte, quelle di Virtuoso e di Redis, sono utilizzate internamente all'interno del network di Docker. In questo modo si minimizza la possibilità che l'utente abbia quelle porte già occupate e debba sapere come liberarle.
  * No indice testuale perché consuma troppa ram e non ce n'è bisogno con così pochi dati
  * Ho limitato a 100 il numero di risorse sia perché questo non è un test di performance ma di usabilità sia perché più sono le risorse più RAM e archiviazione viene richiesta all'utente finale, creando potenzialmente problemi sui classici portatili di merda con 8GB di RAM di cui 4 occupati da Windows
  * Risorse richieste:
    * RAM 530 MiB, ho approssimato a 1G
    * Disco: 3.2 GB per le immagini e 1.3 GB per i volumi locali, approssimato a 5G
  * Perché 3 immagini anziché una?
    * Perché la filosofia di Docker è 1 processo 1 container. Avere più processi necessità di supervisord, aumentando la complessità
    * Un'unica immagine contenente tutto pesa di più, perché le singole immagini di virtuoso alpine e redis alpine sono estremamente ottimizzate
    * Ho tolto dallo shal e dalle regole di visualizzare per l'utente finale tutto ciò che non è nell'OCDM
* [https://12factor.net/](https://12factor.net/)
  * Variabili di configurazione come variabili d'ambiente. In questo modo possono essere passate a un docker compose, rendendo superfluo il file config.py

### Feature

* shortcut per ripristinare una versione precedente direttamente dalla linea del tempo senza necessità di entrare nel dettaglio della versione

### Bugfix

* Modalità demo in http, così non ci sono avvisi di sicurezza dal browser da accettare
* Ho reso più sofisticata la classe che si occupa di generare gli URI secondo il modello di Meta, in maniera tale che accetti come supplier prefix una espressione regolare che permetta di inizializzare i contatori anche per molteplici supplier prefix all'interno dello stesso dataset esattamente come in OpenCitations Meta 06\[1-9]+0.
  * Di conseguenza occorre un nuovo parametro per specificare quale supplier prefix utilizzare da adesso in poi.
  * No, ho completamente cambiato idea. Ho eliminato l'approccio a espressione regolare in quanto noi non abbiamo bisogno di avere dei contatori per tutti i prefissi e per tutte le entità ma soltanto per quelli che andremo a incrementare. quindi in realtà a noi interessa calcolare soltanto i conteggi per le entità che hanno il prefisso specificato non per tutti i prefissi
  * E invece no, per la provenance mi servono tutti...
  * Ogni prefisso ha contatori separati
* risolto un bug che si verificava nella creazione e concomitante riordinamento di entità ordinate per cui ~~i link di ordinamento venivano creati prima che la successiva nuova entità proxy venisse creata creando di fatto un link al vuoto.~~ Filtrare sia per predicato che per shape causava l'invio al backend di liste di nuove entità ordinate vuote in quanto l'informazione sulla shape non era presente e francamente non è neanche utile perché l'ordinamento, il cambio di ordinamento avviene sempre all'interno della medesima shape.
* Il pulsante di ripristino di una versione ora è verde pieno perché in versione outline, warning, arancione su sfondo bianco era invisibile. Ho scelto il verde perché è un'azione più marcata delle altre quindi la volevo caratterizzare e  perché il ripristino è qualcosa di positivo.
* Trovato un bug che si verifica quando si collegano entità a entità già esistenti. Il problema è il seguente: se le entità già esistenti non hanno uno snapshot di provenance, il sistema non riesce a generarlo automaticamente. Anche se l'applicazione è progettata per creare gli snapshot di provenance in modo lazy solo quando le entità vengono coinvolte in operazioni, in questo caso specifico il sistema non trova le entità (perché non erano precedentemente collegate all'entità principale) e di conseguenza non genera lo snapshot di creazione necessario.
  * Il medesimo problema si pone in fase di creazione di un'entità, quando la si collega a entità preesistenti
* Da quando ho migrato Heritrace su docker ho notato dei problemi di comunicazione tra l'applicazione e i database. Ho finalmente capito perché. Il problema era che i container dei database e il container dell'applicazione non erano nello stesso network.
  * Quando i servizi Docker comunicano attraverso indirizzi IP locali esterni alla rete Docker, la comunicazione deve attraversare diversi livelli di rete aggiuntivi. Il traffico esce dal container, passa attraverso il bridge Docker predefinito, viene processato dal sistema host, e poi raggiunge il servizio di destinazione. Questo percorso introduce latenza aggiuntiva e potenziali punti di fallimento.
  * Al contrario, quando utilizzi un Docker network dedicato, i container comunicano direttamente attraverso l'infrastruttura di rete interna di Docker. Questo offre diversi vantaggi: la risoluzione DNS interna è più veloce ed efficiente, il traffico non deve uscire dall'ambiente containerizzato, e Docker può ottimizzare il routing tra i servizi.
  * Dal punto di vista delle prestazioni, la rete interna Docker utilizza bridge virtuali ottimizzati che minimizzano l'overhead di rete. Inoltre, la comunicazione interna beneficia di meccanismi di caching e ottimizzazioni specifiche dell'orchestratore Docker.
  * L'ho scritto nella documentazione
* Il problema di performance che si verificava nella pagina di creazione di nuove entità, in particolare nella selezione di entità con numerose sottoentità annidate, era legato esclusivamente all'inizializzazione degli elementi obbligatori e in particolare all'evento click che doveva essere triggerato sui pulsanti per aggiungere tali proprietà obbligatorie. Ho risolto il problema senza modificare minimamente la logica generale ma rendendo tale operazione di click asincrone, in maniera tale che l'esperienza del cliente risulti più fluida. Inoltre ora le operazioni di click avvengono in batch nel senso che avvengono al massimo tre operazioni per 10 millisecondi in maniera tale da evitare dei freeze della schermata

### CI-CD

Esteso il workflow di release per aggiungere, oltre alla pubblicazione di una nuova versione su github del sorgente, anche di un'immagine su Docker Hub e sul GitHub Container Registry. È sufficiente sempre inserire \[release] nel testo del commit.

### Docs

* Matrice di interazione tra SHACL e display rules. [https://opencitations.github.io/heritrace/configuration/shacl/](https://opencitations.github.io/heritrace/configuration/shacl/)

## Domande

> c) iscritti a corsi di Dottorato: possono svolgere attività di tutorato didattico nel limite massimo complessivo di n.
> 60 ore per ciascun anno accademico. Di conseguenza non possono candidarsi per attività di tutorato che prevedano un
> numero di ore superiore alle n. 60. Tale limitazione non sussiste se il candidato ha già maturato la frequenza prevista
> per la durata legale del corso di dottorato (3 o 4 anni). Il candidato risultato vincitore, se iscritto a dottorato di ricerca,
> prima dell’inizio dell’attività, deve acquisire l’autorizzazione del collegio dei docenti, previo parere favorevole del
> supervisore.

* Problema venues
* * Ma voi aggiungete pubblicazioni a mano a Web of Science? Perché sul mio profilo ce ne sono veramente veramente poche. Tipo nessuna pubblicazione su Aldrovandi
* Secondo voi dovrei fare dei post su Linkedin, Mastodon e Twitter quando pubblico un articolo? Ha ancora senso farlo? Ad oggi cosa si utilizza per misurare le altmetrics?
* This operation retrieves the citation data for all the references appearing in the reference lists of other citing works to the bibliographic entity identified by the input PID (DOI, PMID, OMID), that constitute the incoming citations of that identified bibliographic entity.
  ... Ci ho messo parecchio a capire cosa ci fosse scritto qui, e ci lavoro. Non si può scrivere semplicemente "This operation retrieves all the citations that reference the specified resource." Può essere che mi sto rincoglionendo eh...
* ![attachments/f759351112ab4ccdba042d640471ad16.png](../../../../assets/notes/attachments/f759351112ab4ccdba042d640471ad16.png)
  Andrea Schimmenti ha provato a cercare con l'URL di un DOI e non funziona. Come lui penso tanti altri. Rendere la regex più permissiva...?

```sparql
PREFIX cito: <http://purl.org/spar/cito/>
PREFIX dcterms: <http://purl.org/dc/terms/>

SELECT ?citation ?citing_entity ?title WHERE {
    ?citation a cito:Citation .
    ?citation cito:hasCitedEntity <https://w3id.org/oc/meta/br/062501777134> .
    ?citation cito:hasCitingEntity ?citing_entity .
    
    
    SERVICE <https://sparql.opencitations.net/meta> {
        ?citing_entity dcterms:title ?title .
    }
}
LIMIT 1
```

* Perché questa federata non va?
* ![attachments/689731b93f4944ebb1d4f79affe3caac.png](../../../../assets/notes/attachments/689731b93f4944ebb1d4f79affe3caac.png) quando lanci una query e hai preimpostato table, il bottone di download per table non funziona
* se invece premi qualunque altro bottone della radio list, tipo pivot table, e poi torni su table, si riattiva
* Sbaglio o non c'è un operazione api per ottenere i metadati a partire dalle citazioni in un unico colpo? C'era in passato, perché non la rimettiamo?
* Bottone di download dalla searchbar
* Parsing della tabella html perché non capiva come passare dagli OMID ai DOI
* dove si trova la documentazione dello SPARQL endpoint?
* Le query sull'indice testuale di virtuoso possono essere imprecise. Ad esempio, se stiamo cercando l'ORCID 0000-0002-8420-0696, con 0000- lo trova, ma con 0000-0 no. Questo secondo me dipende da come avviene la tokenizzazione, che ipotizzo essere \["0000", "0002", "8420", "0696"]
