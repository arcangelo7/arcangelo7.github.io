---
{"publish":true,"created":"2025-10-15T16:14:46.537+02:00","modified":"2022-03-09T12:00:00.000+01:00","cssclasses":""}
---


## Cosa ho fatto

1. Ora vengono **preprocessati tutti** i **tipi** di risorse bibliografiche che possono fare da **venue** e solo nel caso in cui siano state pubblicate da pi√π di una casa editrice.
    - Pi√π specificamente, vengono preprocessate le risorse bibliografiche di tipo book, book series, book set, edited book, journal, journal volume, journal issue, monograph, proceedings series, proceedings, reference book, report series, standard series.
        - Il tipo della venue viene dedotto dal tipo di risorsa contenuta. Ad esempio, se la risorsa √® di tipo ‚Äúreference entry‚Äù, la venue √® di tipo ‚Äúreference book‚Äù se ha un ISBN, ‚Äújournal‚Äù se ha un ISSN.
            
            ```python
            def get_venue_type(br_type:str, venue_ids:list) -> str:
                if br_type in {'journal article', 'journal volume', 'journal issue'}:
                    venue_type = 'journal'
                elif br_type in {'book chapter', 'book part', 'book section', 'book track'}:
                    venue_type = 'book'
                elif br_type in {'book', 'edited book', 'monograph', 'reference book'}:
                    venue_type = 'book series'
                elif br_type == 'proceedings article':
                    venue_type = 'proceedings'
                elif br_type in {'proceedings', 'report', 'standard'}:
                    venue_type = 'series'
                elif br_type == 'reference entry':
                    schemas = {venue_id.split(':')[0] for venue_id in venue_ids}
                    if 'isbn' in schemas and 'issn' not in schemas:
                        venue_type = 'reference book'
                    elif 'issn' in schemas and 'isbn' not in schemas:
                        venue_type = 'journal'
                    elif 'issn' in schemas and 'isbn' in schemas:
                        # It is undecidable
                        venue_type = ''
                elif br_type == 'report series':
                    venue_type = 'report series'
                elif not br_type:
                    venue_type = ''
                return venue_type
            ```
            
            <aside>
            üí° Questa stessa euristica aggiornata viene utilizzata anche dal Creator per decidere che tipo di venue generare.
            
            </aside>
            
        - Il software crasha (UnboundLocalError) se una risorsa per cui non √® prevista venue ha una venue. Questo comportamento √® utile per individuare nuove regole di contenimento.
    - √à **inefficiente** preprocessare tutte le venue solo perch√© in rarissimi casi alcune venue sono state pubblicate da pi√π di una casa editrice. Pertanto, ora vengono **preprocessate solo** le **venue multi-publisher**.
        - √à un algoritmo in 5 step:
            1. Vengono individuate tutte le venue in tutti i file in input, in modo da generare un dizionario ridondante in cui ogni id √® una chiave.
            2. Vengono individuate le venue multi-publisher. 
                - Le venue multi-publisher vengono individuate sia se i loro identificativi compaiono nel campo ‚Äúvenue‚Äù sia se compaiono nel campo ‚Äúid‚Äù.
            3. A partire dal dizionario ridondante, viene generato un nuovo dizionario che √® un sottoinsieme del primo e contiene solo le venue-multipublisher.
            4. Le venue multi-publisher vengono unite sulla base degli identificativi.
            5. Le venue-multipublisher vengono esportate in CSV seguendo lo schema di Meta.
2. Ho aggiornato crossref_processing per permettergli di gestire **tutti** i **tipi** di **risorse bibliografiche** previsti da **Crossref**, sia per quanto riguarda gli schemi dei loro id, che per quanto riguarda gli schemi degli id delle venue che li contengono.
3. Se ‚Äútype‚Äù √® uguale a ‚Äú**journal volume**‚Äú e sono presenti valori sia nel campo ‚Äúvolume‚Äù che nel campo ‚Äúissue‚Äù, entrambi i campi vengono **invalidati**. Se ‚Äútype‚Äù √® uguale a ‚Äú**journal**‚Äú e sono presenti valori nel campo ‚Äúvolume‚Äù o nel campo ‚Äúissue‚Äù, tutti i campi vengono invalidati. Entrambi i comportamenti sono stati **testati**. 
4. Se nel CSV viene specificato un **metaid non** presente **sul triplestore**, tale metaid nel CSV viene **invalidato** e ne viene generato uno nuovo. Un MetaID invalido viene invalidato in qualunque campo (id, author, venue, publisher, editor).
5. Ho testato il caso in cui un **volume** o un **issue** hanno un **titolo**.
6. Novit√† relative all‚Äôarticolo sulle **time-traversal queries**:
    - Pubblicare su **JASIST** rimane difficile anche rimuovendo interamente il capitolo sulla libreria. Il conto della **parole** passa infatti da 15,376 a **9,834**, su un massimo di **7,000** concesso dalla rivista.
    - Ho selezionato **20 entit√† casuali** su cui ripetere i benchmark che prevedono un soggetto. L‚Äôunico requisito √® che fossero entit√† di tipo foaf:Expression con citazioni, perch√© la query riguarda appunto questo genere di entit√†.
        - Esse hanno un numero variabile di snapshot di provenance, che va da un minimo di 2 a un massimo di 35. In media hanno 20 snapshot, la mediana √® 20 e la deviazione standard 8.
    - Ho aggiunto media e deviazione standard all‚Äôoutput dei benchmark.

## Domande

1. In Crossref, attualmente, non c‚Äô√® nessun proceedings dotato di ISBN e non ci sono nemmeno proceedings-article che specificano l‚ÄôISBN del contenitore. Dovrei comunque prevedere la possibilit√† che ci√≤ accada? S√¨.
2. In caso di riga vuota o riga contenente valori invalidi, Meta genera comunque un MetaId per quella riga e carica sul triplestore una risorsa bibliografica vuota. Siete d‚Äôaccordo con questo comportamento? No, bisogna eliminare quella risorsa.
3. Come fa Meta a capire se la venue di un book √® di tipo book series o book set? Al momento questi due tipi di venue non vengono gestiti dal creator, n√© vengono appiattiti in un generico ‚Äòseries‚Äô dal curator. Solo una book series ha un ISSN.
4. Meta appiattisce il tipo ‚Äúdissertation‚Äù in ‚Äùbook‚Äù. Propongo invece di conservare ‚Äùdissertation‚Äù, dato che esiste fabio:Thesis e che oc_ocdm mette a disposizione il metodo create_dissertation. Da fare.
5. Non ho pi√π accesso ai file su SharePoint di OpenAIRE-Nexus, perch√© la e-mail abilitata √® arcangelo.massari2, con la quale non posso pi√π accedere a SharePoint visto che l‚Äôho cambiata in arcangelo.massari. A chi mi devo rivolgere per abilitare la nuova e-mail? Androiniki.
6. Usa informazione sullo schema degli id anche per validare gli altri tipi.